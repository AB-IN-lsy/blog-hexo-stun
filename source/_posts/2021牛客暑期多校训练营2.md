---
title: 2021牛客暑期多校训练营2
tags:
  - 牛客暑期多校训练营
categories:
  - [ACM]
  - [Match Solution]
toc: true
quicklink: true
math: true
sidebar: true
copyright: true
reward: true
date: 2022-01-06 21:45:56
---
{% note info %}
**摘要**
D, I, K（单调栈）
{% endnote %}
<!-- more -->
<font color=#000000	size=3 face=楷体>Powered by:**NEFU AB-IN**</font>

@[TOC](文章目录)

# <font color=#6495ED size=6>I.Penguins</font>

* ## 题意

  题目给定两个并列的迷宫，左侧以右下角为起点，右上角为终点，右侧以左下角为起点，左上角为终点。左边上下移动，右侧同样上下移动；左侧左右移动，右侧与左侧相反方向移动。一侧被墙挡住或者到达边界时会停止运动，而且不影响另外一侧的移动。输出左侧移动的的路径长度、路径、路径矩阵。多路径输出字典序最小路径。

* ## 思路

  其实就是简单的BFS，比赛时思路一直被F缠住了，导致这题最后没时间打出来。思路就是当两个目标同时移动的时候，可以用一个**四维数组**记录他们两个的位置状况，即$vis[x1][y1][x2][y2]$​记录当前位置$(x_1, y_1),(x_2, y_2)$​​​的状态，“0”表示没走过，正常走流程就行了。
  
* ## 注意

  好久没写BFS，好多注意的方面都忘了，又翻了一些大佬写的代码，感觉收获挺多，在这记录一下。

  * 当两个对象移动时，对象对着的$dir$​还有数组，要一一对应，要不然调试起来很难发现哪错了

  * 将能走的地点标记成“1”，不能走的标记成“0”，这样相当于自动规划了边界，当按照题目还原路径时，就不用判断边界问题了

  * 由于没有系统的学过$C++$，导致看大佬代码里$struct$​​里的构造函数，以及类的函数就很蒙。特意学习了一下，减少了很多代码量。比如

    ```cpp
    sa(int x1, int y1, int x2, int y2, string s  = ""): x1(x1), x2(x2), y1(y1), y2(y2), s(s) {};
    ```

    属于构造函数中的的**初始化列表**，这样在类中写关于操作对象的函数了，比如

    ```cpp
    sa add(int dx1, int dy1, int dx2, int dy2){
        sa newst(x1 + dx1, y1 + dy1, x2 + dx2, y2 + dy2, s);
        return newst;
    }
    ```

    属于声明一个$sa$​的对象`newst(x1 + dx1, y1 + dy1, x2 + dx2, y2 + dy2, s)`，进行操作并返回。

    这样的好处就是不用单拎$sa$类的对象的每个参数出来，直接以对象为最小单元进行操作即可，即减少了代码量也提高了容错率。

```cpp
/*
 * @Description: file content
 * @Author: NEFU AB_IN
 * @version: 1.0
 * @Date: 2021-07-21 18:04:20
 * @LastEditors: NEFU AB_IN
 * @LastEditTime: 2021-07-21 21:36:33
 */
#include<bits/stdc++.h>
using namespace std;
#define LL                          long long
#define ULL                         unsigned long long
#define SZ(X)                       ((int)(X).size())
#define IOS                         ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
typedef pair<int , int>             PII;

struct sa{
    int x1, y1, x2, y2;
    string s;
    sa(int x1, int y1, int x2, int y2, string s  = ""): x1(x1), x2(x2), y1(y1), y2(y2), s(s) {};
    sa add(int dx1, int dy1, int dx2, int dy2){
        sa newst(x1 + dx1, y1 + dy1, x2 + dx2, y2 + dy2, s);
        return newst;
    }
};

int vis[25][25][25][25]; // status

int a1[25][25], a2[25][25]; // two distinct graph

const int dir1[4][2] = { {1, 0}, {0, -1}, {0, 1}, {-1, 0} }; //下左右上 D L R U
const int dir2[4][2] = { {1, 0}, {0, 1}, {0, -1}, {-1, 0} }; //下右左上 D R L U
const char step_n_c[] = {'D', 'L', 'R', 'U'};
map <char, int> step_c_n = {{'D', 0}, {'L', 1}, {'R', 2}, {'U', 3}};

string bfs(){
    queue <sa> q;
    vis[20][20][20][1] = 1;
    q.push(sa(20, 20, 20, 1));
    while(q.size()){
        sa t = q.front();
        q.pop();
        if(t.x1 == 1 && t.y1 == 20 && t.x2 == 1 && t.y2 == 1) {
            return t.s;
        }
        for(int i = 0; i < 4; i ++){
            // init new sa variable
            sa now = t.add(dir1[i][0], dir1[i][1], dir2[i][0], dir2[i][1]);
            if(!a1[now.x1][now.y1] || now.x1 < 1 || now.y1 < 1 || now.x1 > 20 || now.y1 > 20){
                now = now.add(-dir1[i][0], -dir1[i][1], 0, 0);
            }// If its way is blocked, or it reaches the border, then this movement is omitted.
            if(!a2[now.x2][now.y2] || now.x2 < 1 || now.y2 < 1 || now.x2 > 20 || now.y2 > 20){
                now = now.add(0, 0, -dir2[i][0], -dir2[i][1]);
            }
            if(!vis[now.x1][now.y1][now.x2][now.y2]){
                now.s += step_n_c[i];
                vis[now.x1][now.y1][now.x2][now.y2] = 1;
                //cout << now.x1 << " " << now.y1 << " " << now.x2 << " " << now.y2 << endl;
                q.push(now);
            }
        }
    }
    return "None";
}

void solve(string ans){
    //  sign path
    int x1 = 20, y1 = 20, x2 = 20, y2 = 1;
    a1[x1][y1] = 2, a2[x2][y2] = 2;
    for(auto c : ans){
        int id = step_c_n[c];
        if(a1[x1 + dir1[id][0]][y1 + dir1[id][1]]) { // not block, so sign 2
            x1 = x1 + dir1[id][0];
            y1 = y1 + dir1[id][1];
            a1[x1][y1] = 2;
        }
        if(a2[x2 + dir2[id][0]][y2 + dir2[id][1]]) {
            x2 = x2 + dir2[id][0];
            y2 = y2 + dir2[id][1];
            a2[x2][y2] = 2;
        }
    }
    //  print
    for(int i = 1; i <= 20; i++){
        for(int j = 1; j <= 20; j++){
            if(a1[i][j] == 1) putchar('.');
            else if(a1[i][j] == 0) putchar('#');
            else if(a1[i][j] == 2) putchar('A');
        }
        putchar(' ');
        for(int j = 1; j <= 20; j++){
            if(a2[i][j] == 1) putchar('.');
            else if(a2[i][j] == 0) putchar('#');
            else if(a2[i][j] == 2) putchar('A');
        }
        putchar('\n');
    }
}


int main()
{
    char x;
    for(int i = 1; i <= 20; i ++){
        for(int j = 1; j <= 20; j ++){
            scanf("%c", &x);
            a1[i][j] = x == '.' ? 1 : 0; // 1 represent there is a path, so that
                                         // donot worry the border
        }
        scanf("%c", &x);
        for(int j = 1; j <= 20; j ++){
            scanf("%c", &x);
            a2[i][j] = x == '.' ? 1 : 0; 
        }
        getchar();
    }

    string ans = bfs();
    printf("%d\n", ans.size());
    cout << ans << endl;
    solve(ans);    
    return 0;
}

```

